## 什么是访问者模式

访问者模式是一种行为型设计模式，其主要目的是将一个算法从它所作用的对象结构中分离出来。它允许你在不修改对象结构的前提下，为这些对象添加新的操作。

简单来说，想象你是一个**“检查员”或“审计员”**。你需要对公司里的不同部门（比如财务部、人力资源部、销售部）进行检查。每个部门都有自己的特点和要检查的项目，但你作为检查员，有一套标准的检查流程。访问者模式就是让你（访问者）可以“访问”这些不同的部门（元素），并在访问时执行特定的操作，而不需要每个部门自己去实现这些检查逻辑。

## 核心思想

访问者模式将**操作（算法）与对象结构（元素）**分离。对象结构（元素）提供一个 accept()
方法，接受一个访问者对象。当访问者访问某个元素时，元素会回调访问者的特定方法，并将自己作为参数传递过去。这样，具体的访问者就可以在不修改元素类的情况下，对不同类型的元素执行不同的操作。

## 访问者模式的组成部分

访问者模式通常包含以下四个核心角色：

抽象访问者 (Visitor Interface)：

* 定义： 声明一系列 visit() 方法，每个方法都对应一个具体元素类。
* 特点： 定义了访问不同类型元素时的行为。所有具体访问者都必须实现这个接口。
* 例子： Visitor 接口，包含 visit(Salary salary)、visit(Bonus bonus) 等方法。

具体访问者 (Concrete Visitor)：

* 定义： 实现抽象访问者接口中声明的每一个 visit() 方法，为每个具体元素类提供特定的操作实现。
* 特点： 封装了对不同类型元素的操作逻辑。
* 例子： TaxCalculatorVisitor（税率计算访问者）。

抽象元素 (Element Interface)：

* 定义： 声明一个 accept() 方法，该方法接受一个抽象访问者作为参数。
* 特点： 所有具体元素都必须实现这个接口。
* 例子： Taxable 接口，包含 accept(Visitor visitor) 方法。

具体元素 (Concrete Element)：

* 定义： 实现抽象元素接口，并实现 accept() 方法。accept() 方法通常会回调访问者的特定 visit()
  方法，并将自身作为参数传递过去。
* 特点： 维护自身的状态，并提供一个让访问者访问自己的接口。
* 例子： Salary，Bonus。

## 访问者模式的优点

* 分离操作与对象结构： 使得操作（算法）独立于其作用的对象结构。当需要为对象结构添加新的操作时，只需创建新的访问者，而无需修改现有的元素类。这符合开闭原则。
* 集中相关操作： 某个特定操作（如审计）的所有逻辑都被集中在一个访问者类中，而不是分散在各个元素类中，使得代码更易于维护。
* 支持新的操作： 可以在不修改元素类的情况下，为元素添加新的行为。
* 双重分派： 访问者模式通过 accept() 和 visit() 实现了双重分派，即操作的执行不仅取决于调用的方法（accept），还取决于接收者（element）和参数（visitor）的运行时类型。

## 访问者模式的缺点

* 增加复杂性： 引入了额外的访问者接口和具体访问者类，以及元素接口和具体元素类，增加了系统的复杂性。
* 难以添加新的元素类型： 如果对象结构中需要添加新的具体元素类型，那么所有的抽象访问者和具体访问者都需要修改，以添加对新元素的
  visit() 方法。这违背了开闭原则。
* 破坏封装性（某种程度）： 访问者通常需要访问元素类的内部状态，这可能需要元素类暴露一些 getter 方法，从而在一定程度上破坏了元素的封装性。

## 访问者模式的应用场景

* 当对象结构相对稳定，但需要频繁地为这些对象添加新的操作时。
* 当需要对对象结构中的不同类型对象执行不同的操作时。
* 当需要避免在对象结构中混入太多与核心职责无关的操作时。
* 编译器和解释器： 遍历抽象语法树 (AST) 并执行不同的操作（如类型检查、代码生成）。
* XML 或 JSON 解析器： 遍历文档结构并执行不同的处理。
* 对象结构遍历和报告生成： 遍历复杂对象图并生成各种报告。
* 数据分析： 对不同类型的数据记录执行不同的分析算法。