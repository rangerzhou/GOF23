## 什么是备忘录模式

备忘录模式是一种行为型设计模式，其核心思想是：在不破坏对象封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后可以将该对象恢复到这个保存过的状态。

简单来说，它就像游戏中的**“存档/读档”功能**
。你玩游戏时，可以随时保存当前进度（角色的生命值、分数、位置、道具等），然后继续游戏。即使之后角色死亡或状态变差，你也可以从之前保存的“存档点”重新加载，恢复到那个良好的状态，而你作为玩家，不需要知道游戏内部是如何记录这些复杂数据的。

## 核心思想

* 快照 (Snapshot)： 备忘录对象就是发起人对象在某个特定时刻的“快照”。
* 封装性： 备忘录模式的关键在于，看管者（负责管理存档的）无法直接访问或修改存档的内部细节，只有发起人（游戏角色）自己知道如何创建和读取自己的存档。这保护了发起人对象的内部结构。

## 备忘录模式的组成部分 (游戏场景)

发起人 (Originator) - 游戏角色 (GameCharacter)：

* 定义： 拥有需要被保存或恢复状态的对象。
* 在游戏中： 你的游戏角色（例如，一个玩家对象）就是发起人。它有生命值、分数、等级、位置、背包物品等内部状态。它知道如何将自己的当前状态打包成一个“存档点”（备忘录），也知道如何从一个“存档点”中恢复到以前的状态。

备忘录 (Memento) - 游戏存档 (GameMemento)：

* 定义： 存储发起人对象的某个时刻的内部状态。它通常是一个窄接口（或一个标记接口），对外部（特别是看管者）来说是“不透明”的，即看管者无法直接访问其内部的具体状态。
* 在游戏中： 一个游戏存档对象就是备忘录。它包含了游戏角色在保存时的所有关键数据（生命值、分数等）。这个存档对象对“存档管理器”来说，只是一个“黑盒子”，它不知道里面具体存了什么数据，只知道这是一个可以被保存和加载的东西。

看管者 (Caretaker) - 存档管理器 (SaveLoadManager)：

* 定义： 负责存储和管理备忘录对象。它不会对备忘录的内容进行任何操作或检查。它只负责保存和提供备忘录。
* 在游戏中： 游戏中的存档/读档管理器就是看管者。它维护着一个列表，里面存放着你创建的所有“存档点”。当你选择“保存游戏”时，它就把当前状态的“存档点”收起来；当你选择“加载游戏”时，它就把某个“存档点”提供给游戏角色去恢复。它不关心存档点里具体是什么数据，只负责保管。

## 备忘录模式的UML类图

``` mermaid
classDiagram
    class Originator {
        -state: GameState // 例如：health, score, level
        +playGame(actions: String): void
        +createMemento(): Memento
        +restoreMemento(memento: Memento): void
    }

    class Memento {
        <<interface>>
        // 窄接口，对Caretaker透明
    }

    class ConcreteMemento {
        -savedState: GameState // 实际存储的状态
        +ConcreteMemento(state: GameState)
        +getSavedState(): GameState // 仅供Originator内部访问
    }

    class Caretaker {
        -mementoList: List<Memento>
        +addMemento(memento: Memento): void
        +getMemento(index: int): Memento
    }

    Originator --|> ConcreteMemento
    ConcreteMemento ..|> Memento
    Caretaker --o Memento
    Client --> Originator
    Client --> Caretaker
```

## 备忘录模式的优点

* 不破坏封装性： 发起人内部的细节被封装在自己内部，只有发起人自己能够访问和修改这些细节。备忘录对象作为发起人状态的快照，外部（看管者）无法直接访问其内部状态，从而保护了封装性。
* 支持回滚操作： 能够轻松地实现“撤销”、“重做”等功能，将对象恢复到之前的某个状态。
* 简化发起人： 看管者负责管理备忘录的生命周期，发起人不需要关心备忘录的存储细节。
* 职责分离： 发起人负责创建和恢复状态，备忘录负责存储状态，看管者负责管理备忘录，职责明确。

## 备忘录模式的缺点

* 资源消耗： 如果发起人对象的状态非常大，或者需要保存的状态版本很多，那么创建和存储备忘录可能会消耗大量的内存或存储空间。
* 备忘录的粒度： 如果备忘录存储的状态粒度过细，会导致频繁创建备忘录，增加开销。如果粒度过粗，则无法实现精确的回滚。
* 复杂性： 对于简单的状态保存，可能引入不必要的复杂性。

## 备忘录模式的应用场景

* 需要实现撤销 (Undo) 和重做 (Redo) 功能时。
* 数据库事务管理： 事务回滚功能。
* 游戏存档： 保存游戏进度，玩家可以回到之前的存档点。
* 文本编辑器： 保存编辑历史，实现撤销、恢复。
* 工作流引擎： 记录流程的中间状态，以便回溯。