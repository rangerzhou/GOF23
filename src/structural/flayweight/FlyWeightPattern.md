## 什么是享元模式？

享元模式（Flyweight
Pattern）指的是运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。
Flyweight指的是特轻量级拳击手，最轻量级摔跤手的意思,所以享元模式也叫轻量级模式。为什么享元模式叫做Flyweight呢？Flyweight翻译过来就是让让体重飞了，不就是变轻了的意思吗？而享元模式的核心就是通过共享实例减少代码量和对象的数量，不就类似于这个意思吗？
从中文的意思来理解，享元中的享就是共享的意思，而元可以理解为数据、实例，所以享元模式的意思就是共享实例，共享实例这样就能够减少对象实例的频繁的创建了。

通过享元模式的定义我们可以发现有两个重要的定义一个是细粒度对象，另一个是共享对象。细粒度对象就是指性质相近的对象，什么是性质相近呢？可以将对象的属性分为内部状态和外部状态。内部状态往往就是可以共享的相同的内容，而外部状态就是不能共享的，需要通过外部环境来设置的。

享元模式是一种结构型设计模式，其主要目的是通过共享大量细粒度对象来减少内存使用和提高性能。它通过将对象的“内部状态”和“外部状态”分离，并尽可能地共享具有相同内部状态的对象来实现这一点。

内部状态 (Intrinsic State)：不变的，并且可以被共享的状态。它存储在享元对象中，并且不依赖于享元对象的使用环境。
外部状态 (Extrinsic State)：可变的，并且不可共享的状态。它通常由客户端存储或计算，并在享元对象的方法被调用时传递给享元对象。
简单来说，当系统中有大量相似的对象，它们大部分数据是相同的，只有少数数据不同时，我们不为每个对象都创建独立的实例，而是只创建一份共享的对象（享元），把那些不同的数据（外部状态）抽出来，在需要时再传递给享元对象。

## 享元模式的组成部分

享元 (Flyweight)：

* 定义： 声明一个接口或抽象类，通过这个接口享元可以接受并作用于外部状态。
* 特点： 定义了享元对象的公共操作，通常包含一个或多个接受外部状态作为参数的方法。
* 例子： BookFlyWeight 接口，包含 locate(String location) 方法。

具体享元 (Concrete Flyweight)：

* 定义： 实现享元接口，并存储内部状态。
* 特点： 它们是可共享的对象，其内部状态是不可变的。
* 例子： ConcreteBook 类，内部状态是 bookName 属性。

享元工厂 (Flyweight Factory)：

* 定义： 负责创建和管理享元对象。它维护一个享元池（通常是 HashMap 或
  ConcurrentHashMap），当客户端请求一个享元时，它首先检查池中是否已存在具有相同内部状态的享元。如果存在，则返回现有享元；否则，创建新享元并放入池中。
* 特点： 确保享元对象的唯一性。
* 例子： BookFactory 类，负责创建和管理 BookFlyWeight 对象。

客户端 (Client)：

* 定义： 使用享元工厂获取享元对象，并管理外部状态。
* 特点： 客户端负责向享元对象传递外部状态。
* 例子： 查找大量同款图书位置的程序

## 享元模式的优点

* 大大减少内存使用： 通过共享对象，避免了创建大量重复的对象实例。
* 提高性能： 减少了对象创建和垃圾回收的开销。
* 集中管理共享对象： 享元工厂统一管理享元对象的生命周期和获取方式。

## 享元模式的缺点

* 增加复杂性： 引入了享元工厂和内部/外部状态的区分，增加了设计的复杂性。
* 运行时代价： 外部状态必须在运行时传递给享元对象，这可能在每次调用时带来一些额外的计算或查找开销。
* 分清内部/外部状态的挑战： 正确区分和管理对象的内部和外部状态可能比较困难，尤其是在复杂场景下。

## 享元模式的应用场景

* 当一个系统中有大量对象时。
* 当这些对象大部分都是相同或相似的，即具有相同的内部状态时。
* 当这些对象的内部状态可以被共享时。
* 当客户端需要创建大量对象，且系统资源（尤其是内存）有限时。
* 文本编辑器： 字符的字体、大小、颜色是内部状态，字符的位置是外部状态。
* 图形编辑器/游戏： 树木、方块、粒子的纹理、颜色、模型是内部状态，它们在屏幕上的坐标位置是外部状态。