## 什么是享元模式？

享元模式是一种结构型设计模式，其主要目的是通过共享大量细粒度对象来减少内存使用和提高性能。它通过将对象的“内部状态”和“外部状态”分离，并尽可能地共享具有相同内部状态的对象来实现这一点。

内部状态 (Intrinsic State)：不变的，并且可以被共享的状态。它存储在享元对象中，并且不依赖于享元对象的使用环境。
外部状态 (Extrinsic State)：可变的，并且不可共享的状态。它通常由客户端存储或计算，并在享元对象的方法被调用时传递给享元对象。
简单来说，当系统中有大量相似的对象，它们大部分数据是相同的，只有少数数据不同时，我们不为每个对象都创建独立的实例，而是只创建一份共享的对象（享元），把那些不同的数据（外部状态）抽出来，在需要时再传递给享元对象。

## 享元模式的组成部分

享元 (Flyweight)：

* 定义： 声明一个接口或抽象类，通过这个接口享元可以接受并作用于外部状态。
* 特点： 定义了享元对象的公共操作，通常包含一个或多个接受外部状态作为参数的方法。
* 例子： BookFlyWeight 接口，包含 locate(String location) 方法。

具体享元 (Concrete Flyweight)：

* 定义： 实现享元接口，并存储内部状态。
* 特点： 它们是可共享的对象，其内部状态是不可变的。
* 例子： ConcreteBook 类，内部状态是 bookName 属性。

享元工厂 (Flyweight Factory)：

* 定义： 负责创建和管理享元对象。它维护一个享元池（通常是 HashMap 或
  ConcurrentHashMap），当客户端请求一个享元时，它首先检查池中是否已存在具有相同内部状态的享元。如果存在，则返回现有享元；否则，创建新享元并放入池中。
* 特点： 确保享元对象的唯一性。
* 例子： BookFactory 类，负责创建和管理 BookFlyWeight 对象。

客户端 (Client)：

* 定义： 使用享元工厂获取享元对象，并管理外部状态。
* 特点： 客户端负责向享元对象传递外部状态。
* 例子： 查找大量同款图书位置的程序

## 享元模式的优点

* 大大减少内存使用： 通过共享对象，避免了创建大量重复的对象实例。
* 提高性能： 减少了对象创建和垃圾回收的开销。
* 集中管理共享对象： 享元工厂统一管理享元对象的生命周期和获取方式。

## 享元模式的缺点

* 增加复杂性： 引入了享元工厂和内部/外部状态的区分，增加了设计的复杂性。
* 运行时代价： 外部状态必须在运行时传递给享元对象，这可能在每次调用时带来一些额外的计算或查找开销。
* 分清内部/外部状态的挑战： 正确区分和管理对象的内部和外部状态可能比较困难，尤其是在复杂场景下。

## 享元模式的应用场景

* 当一个系统中有大量对象时。
* 当这些对象大部分都是相同或相似的，即具有相同的内部状态时。
* 当这些对象的内部状态可以被共享时。
* 当客户端需要创建大量对象，且系统资源（尤其是内存）有限时。
* 文本编辑器： 字符的字体、大小、颜色是内部状态，字符的位置是外部状态。
* 图形编辑器/游戏： 树木、方块、粒子的纹理、颜色、模型是内部状态，它们在屏幕上的坐标位置是外部状态。