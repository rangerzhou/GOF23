## 什么是外观模式？

外观模式（Facade Pattern）是一种结构型设计模式，其核心目的是为子系统中的一组复杂接口提供一个统一的、高层的接口，从而使得该子系统更容易使用。
简单来说，当一个系统有很多相互关联且复杂的类，客户端需要与这些类中的多个对象进行交互才能完成一项任务时，外观模式就像一个
**总开关** 或 **遥控器**。
它提供一个简单的入口点，客户端只需要调用外观对象的一个方法，外观就会在内部协调并调用子系统中多个相关类的相应方法，从而隐藏了底层的复杂性。

## 外观模式的组成部分

外观 (Facade)：

* 定义： 提供一个统一的、高层的接口。它知道哪些子系统类负责处理请求，并将客户端的请求委派给适当的子系统对象。
* 特点： 它通常是一个单一的类，不包含业务逻辑，只负责协调子系统中的类。
* 例子： 一个家庭影院的“遥控器”或“一键观影”按钮。

子系统类 (Subsystem Classes)：

* 定义： 实现子系统功能的各个独立类。它们执行实际的工作，并且不了解外观，也不持有外观的引用。
* 特点： 每个子系统类都有自己的职责。
* 例子： 电视机、音响、DVD 播放器、灯光系统。

客户端 (Client)：

* 定义： 使用外观接口与子系统交互的代码。
* 特点： 客户端只与外观对象交互，无需了解子系统内部的复杂性。
* 例子： 观看电影的人。

## 外观模式的优点

* 简化客户端接口： 降低了客户端与复杂子系统交互的复杂性，使系统更容易使用。
* 解耦： 客户端与子系统之间解耦。客户端不需要知道子系统的内部结构和相互关系。
* 提高可维护性： 更改子系统时，如果外观接口不变，客户端代码无需修改。
* 分层： 有助于构建多层系统，提供一个清晰的入口点。

## 外观模式的缺点

* 可能增加代码量： 引入了一个新的外观类。
* 违背开闭原则（某种程度）： 如果需要为子系统添加新的功能，可能需要修改外观类，这可能会违背开闭原则。然而，外观模式的主要目的是简化，而不是扩展。
* 过度依赖： 客户端可能会过度依赖外观，导致外观变得臃肿，承担过多职责。

## 外观模式的应用场景

* 当一个复杂系统有许多类，并且这些类之间的依赖关系复杂时。
* 当需要为复杂的子系统提供一个简单的入口点时。
* 当需要将客户端与子系统解耦时。
* 当构建分层系统时，外观模式可以定义每一层的入口点。