# GOF 23

## 🧱 创建型模式 (Creational Patterns)

关注对象的创建机制，优化对象的创建方式。

| 模式                            | 解决问题                                                     | 举例                                                         |
| ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **单例模式 (Singleton)**        | 保证一个类仅有一个实例，并提供全局访问点。                   | 系统中的配置类、Log 日志系统。                               |
| **工厂方法 (Factory Method)**   | 定义一个用于创建对象的接口，让子类决定实例化哪一个类。       | 不同的汽车，每种汽车通过各自工厂生产，需要什么汽车就去哪家汽车工厂 |
| **抽象工厂 (Abstract Factory)** | 提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体类。 | 需要一套小米风格的产品，你给我一个小米工厂，它能给我所有小米风格的产品 |
| **建造者模式 (Builder)**        | 将一个复杂对象的构建过程与其表示分离，使同样的构建过程可以创建不同的表示。 | 创建一辆汽车：一步步设置引擎、轮胎、颜色等。                 |
| **原型模式 (Prototype)**        | 用原型实例指定创建对象的种类，并通过克隆这些原型创建新对象。 | 游戏角色复制、图形编辑器复制图层（深浅拷贝问题）。           |



## 🧱 结构型模式 (Structural Patterns)

关注类和对象之间的组合关系，优化结构以实现功能。

| 模式                       | 解决问题                                           | 举例                                                         |
| -------------------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| **适配器模式 (Adapter)**   | 连接两个不兼容的接口，使它们能协同工作。           | 电源插座转换器，或者旧接口转新接口的兼容桥接类。             |
| **桥接模式 (Bridge)**      | 将抽象和实现解耦，使它们可以独立变化。             | 颜色（红色、蓝色）与形状（三角形、圆形）的组合               |
| **组合模式 (Composite)**   | 将对象组合成树形结构，统一对单个和组合对象的使用。 | 文件系统，文件和文件夹都可以被统一处理。                     |
| **装饰者模式 (Decorator)** | 动态添加功能而不修改原有类。                       | 一个Coffee接口，简单咖啡实现它，可以在简单咖啡的基础上加上焦糖、牛奶等 |
| **外观模式 (Facade)**      | 提供一个统一接口，屏蔽子系统的复杂性。             | 家庭影院遥控器封装音响、灯光、屏幕等多个子系统。             |
| **享元模式 (Flyweight)**   | 共享对象以减少内存使用（大量小对象场景）。         | 文本编辑器中字符对象复用，棋盘中的棋子共享对象。             |
| **代理模式 (Proxy)**       | 为其他对象提供一个代理以控制对其的访问。           | 网络代理、安全代理、AIDL 中的 Stub/Proxy。                   |



## 🔁 行为型模式 (Behavioral Patterns)

关注对象之间的通信和职责分配。

| 模式                                     | 解决问题                                           | 举例                                                         |
| ---------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| **责任链模式 (Chain of Responsibility)** | 多个对象可以处理请求，避免请求发送者与接收者耦合。 | Android 事件分发（onTouch → ViewGroup → View）。<br />请假，通过 TeamLeader -> Manager -> Director 分级处理 |
| **命令模式 (Command)**                   | 将请求封装为对象，支持日志、撤销、排队等功能。     | 遥控器按钮通过设置开/关等命令控制灯的开关。<br />Android Button 的 setOnClickListener 点击事件 |
| **解释器模式 (Interpreter)**             | 定义语言的文法，并建立解释器解析表达式。           | 正则表达式解析器、数学表达式求值。                           |
| **迭代器模式 (Iterator)**                | 顺序访问集合元素，不暴露内部结构。                 | 图书馆添加数据并创建迭代器，客户端使用迭代器遍历书籍         |
| **中介者模式 (Mediator)**                | 用一个中介对象封装对象之间的交互。                 | 聊天室、MVP 中的 Presenter。                                 |
| **备忘录模式 (Memento)**                 | 保存对象状态以便恢复，支持撤销。                   | 游戏存档管理员添加存档，存档由玩家创建及恢复                 |
| **观察者模式 (Observer)**                | 对象状态变化通知所有依赖对象。                     | 订阅-发布、广播机制、LiveData。                              |
| **状态模式 (State)**                     | 对象在不同状态下表现不同行为。                     | 我根据当前状态决定做什么：按下电视机电源按钮根据电视机当前状态执行不同的操作，状态由对象切换 |
| **策略模式 (Strategy)**                  | 定义一系列算法，把它们封装起来并且可以互换。       | 我来决定要怎么做：按下电视机电源按钮之前，先手动设置电视机为开机/关机状态 |
| **模板方法模式 (Template Method)**       | 定义算法框架，将某些步骤延迟到子类实现。           | 定义饮料抽象类，包含抽象方法（需要子类实现）以及通用方法（抽象类实现），子类根据需求各自实现抽象方法 |
| **访问者模式 (Visitor)**                 | 在不修改数据结构的情况下添加新的操作。             | 访问者接口声明 visitor() 方法，被访问者接口声明 accept(Visitor visitor) 方法，实现 accept() 的时候调用 visitor() 方法 |



